%%
%% This is file `sample-sigconf-authordraft.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `all,proceedings,bibtex,authordraft')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf-authordraft.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[sigconf,review]{acmart}
\acmConference{}{}{}
\settopmatter{
  printacmref=false, % remove ACM Reference Format
  printfolios=false  % remove headers/footers
}
\pagestyle{plain}
\renewcommand\footnotetextcopyrightpermission[1]{}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}
%% These commands are for a PROCEEDINGS abstract or paper.

%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2018/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Evolving Research Software: an Experience Report}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
%\author{Name 1}
%\email{someone@somewhere.com}
%\orcid{1234-5678-9012}
%\affiliation{%
%  \institution{University of Somewhere}
%  \city{Placeholder}
%  \country{Somewhere}
%}

%\author{Name 2}
%\email{someone@somewhere.com}
%\orcid{1234-5678-9012}
%\affiliation{%
%  \institution{University of Somewhere}
%  \city{Placeholder}
%  \country{Somewhere}
%}

\author{Authors withheld for review}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  Developing research software often involves collaboration between engineers and scientists, bringing together complementary skills but also creating challenges due to differing goals and working styles. In this work, we reflect on our experience in such a collaborative environment, highlight challenges related to legacy code and collaboration, and discuss strategies that helped balance rapid experimentation with sustainable software development.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007.10011074</concept_id>
       <concept_desc>Software and its engineering~Software creation and management</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Software creation and management}


%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Research Software, Distributed Systems, Software Engineering, Software Maintenance, Team Collaboration, Legacy Software}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

Developing software for research sits at the intersection between scientific exploration and engineering. It is a space where innovation and exploration thrive, but some engineering practices can easily be overlooked. When engineering practices are neglected, projects often become hard to maintain, difficult for others to use, and nearly impossible to reproduce or extend. Over time, this slows down research progress and makes collaboration much harder.

The project we have been working on, Abstraktor, is a tool designed to validate distributed protocol implementations by automatically generating abstractions from real executions, allowing it to detect violations in business logic and ensure that implementations meet their intended guarantees. It builds on two key ideas from prior research: Enabling-Preserving Abstractions (EPAs), which model API behavior as abstract state machines that ignore concrete states, data values, and operation parameters \cite{epas2013}, and Mallory, a greybox fuzzing framework that uses partial visibility into node states to adapt inputs dynamically, improving coverage and uncovering bugs more efficiently than blackbox approaches \cite{meng2023}. However, working with Mallory as legacy research software introduced its own challenges, particularly due to limited documentation and lack of testing, making it difficult to understand, extend, and integrate. Together, these foundations allow Abstraktor to bridge the gap between technical failure detection and functional validation in distributed protocol testing.

The development team consisted of two main contributors: a PhD student working on their thesis and a software engineering student completing their capstone project. Their goals naturally diverged: the PhD student prioritized rapid experimentation to support research progress and paid little attention to the long-term evolution of the project, while the engineering student aimed to build a robust, maintainable system that reflected solid software engineering practices. Both students worked guided by a research director that in terms of the development process could be consider a Product Owner. In this article, we aim to share and reflect on our experience applying software engineering practices in the development of Abstraktor.

\section{Development Process}

To develop Abstraktor we used an Agile-like process \cite{farley2021modern}, with practices like weekly iterations, automated tests and coding conventions among others. We used GitHub for version control and GitHub Projects to manage the backlog and Kanban board. Mallory, the legacy software we built on, is written in C, while Abstraktor is implemented in Rust; we used GCC to compile the C code and Cargo to build the Rust code. Work was organized in weekly agile iterations with tasks prioritized by impact and dependencies and estimated using difficulty scores from 1 to 3.

Testing was a central part of our development process. We followed a hexagonal architecture\cite{cockburn2025hexagonal}, which allowed us to separate core logic from external dependencies and test it thoroughly. The core model was covered extensively with unit tests to ensure correctness in isolation, while integration tests were used to validate interactions with Mallory.

Development is carried out through feature branches and pull requests, which are kept small and include relevant tests to encourage frequent reviews and smooth integration. Coding conventions were enforced using the linter Clippy. A Github workflow runs automated tests and linter to ensure new code changes do not break existing functionality.

Abstraktor builds on Mallory for its greybox fuzzing capabilities, but the team had to work extensively with the legacy code to add new functionality. Working with Mallory’s older and minimally documented code added complexity, but these extensions were essential for Abstraktor to perform functional validation while leveraging Mallory’s existing adaptive testing framework.

\section{Challenges Applying Software Engineering Practices}

Applying these software engineering practices in research software comes with its own set of challenges. Some difficulties arise from collaboration and human factors, such as differing goals and working styles within the team, while others stem from the legacy code we were building on, which sometimes lacked tests, documentation, and clear structure. The following subsections describe the main challenges we encountered while developing Abstraktor.

\subsection{Different Goals and Expectations}

One of the main challenges we encountered was the difference in goals and expectations between research-focused and engineering-focused team members. The PhD developer was primarily interested in experimenting with new ideas and quickly testing prototypes, often at the expense of maintainable code. As a result, practices like testing, modular design, and thorough documentation were sometimes overlooked, creating friction when integrating code or trying to ensure the tool’s maintainability.

To address this, we adopted a hybrid strategy: this developer was allowed to experiment freely and make large changes in their own branches, while the other developer focused on carefully integrating the successful experiments into the main codebase. This approach helped balance rapid research exploration with the need for a stable and maintainable software foundation.

The traditional workflow of submitting pull requests, receiving review comments, and iterating on them was often impractical in this context, as experimentation branches frequently contained hard-coded values, ad-hoc implementations, and lacked the structure needed for direct refinement.

\subsection{Poor Collaboration}

Another challenge we faced was inconsistent use of version control and collaboration practices. Early in the project, some developers worked mostly on local copies without committing their changes, which made it hard to track progress or revert mistakes. When version control was eventually adopted, pull requests were often huge, untested, and difficult to review, slowing down integration and creating additional work for the team.

Once pull requests started to decrease in size and include relevant tests, integration became much faster, and overall development progressed more smoothly. Smaller, well-tested contributions made reviews easier and reduced the likelihood of introducing errors into the main codebase.

The team held weekly syncs, but most work and coordination was done asynchronously.

\subsection{Testing Issues}

Testing was another major challenge. The legacy research software we were building on, Mallory, didn’t have enough tests or coverage, which made it difficult for the team to understand the impact of changes or ensure correctness when modifying the code. Without proper tests, even small modifications carried the risk of introducing bugs or breaking existing functionality, making development slower and more error-prone.

To address this, we developed integration tests between Abstraktor and Mallory. These tests helped ensure that changes did not break the overall workflow and that key functionality remained intact, giving the team more confidence when modifying or extending the code.

We had some automated integration tests, but they were slow to set up and run due to Mallory build and execute times. Because of this, they were excluded from the Github workflow and executed only locally. Other integration tests were left as manual tests with detailed specifications, since automating them would have taken too much time and we prioritized developing new functionality. Over time, this became a recurring issue, as running the manual integration tests also consumed significant time.

\subsection{Documentation Gaps}

Another challenge we faced was the lack of documentation in Mallory. It provided very limited guidance on how to build and run the software, and offered almost no information on its internal components, architecture, or the location of specific logic in the codebase.

As a result, the team spent a significant amount of time trying to understand the system, not just to use it, but also to extend it with additional functionality. This experience highlighted the critical importance of documentation for both current development and future maintainability.

\section{Conclusions}

During the development of Abstraktor, we faced challenges both in collaboration and in working with legacy code. The legacy code presented the usual difficulties associated with understanding, extending, and maintaining existing software, and this project was no exception. Efforts were made to improve the situation by adding tests and documentation, following the practices recommended in Michael Feathers' book\cite{feathers2005working}.

On the human side, the team established a collaboration mechanism that allowed the project to progress while maintaining a standard of quality. There is still room for improvement, and alternative strategies such as more frequent pair programming might have further enhanced coordination and knowledge sharing, especially given the largely asynchronous nature of the work.

Overall, reconciling the need for rapid experimentation with the requirements of long-term software maintenance remains a core challenge in research software projects. By sharing our experiences with Abstraktor, we hope to encourage discussion on approaches and techniques that can support both exploratory research and development of maintainable software.


%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}

\end{document}
\endinput
%%
%% End of file `sample-sigconf-authordraft.tex'.
