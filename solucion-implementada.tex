\section{Solución implementada}

La solución se implementó como una herramienta de línea de comandos que automatiza la generación de abstracciones (EPAs) para protocolos distribuidos implementados en C/C++. La herramienta integra diferentes componentes y aplicaciones en un flujo de trabajo unificado.

\subsection{Arquitectura}

La arquitectura se basa en tres programas principales:

\vspace{0.5cm}

{\centering
\begin{tikzpicture}[
  mainbox/.style={rectangle, draw, thick, rounded corners, minimum width=4cm, minimum height=1.2cm, align=center, font=\small, fill=blue!10},
  component/.style={rectangle, draw, rounded corners, minimum width=3.5cm, minimum height=1cm, align=center, font=\small, fill=white},
  output/.style={rectangle, draw, dashed, rounded corners, minimum width=3.5cm, minimum height=1cm, align=center, font=\small, fill=green!10},
  arrow/.style={-{Latex[length=3mm]}, thick},
  bidir/.style={<-{Latex[length=3mm]}, thick},
  edgelabel/.style={font=\tiny, text=gray, align=center}
]

\node[component] (cli) at (0,0) {CLI Abstraktor\\(Rust)};
\node[component] (llvm) at (-3,-2.5) {Instrumentador\\LLVM (C)};
\node[component] (mallory) at (3,-2.5) {Fuzzer Mallory\\(Clojure/Rust)};
\node[output] (abstractions) at (5, 0) {Abstracciones\\(EPAs)};

\draw[bidir] (cli) -- (llvm) node[midway, above left, edgelabel] {JSON targets};
\draw[bidir] (cli) -- (mallory) node[midway, above right, edgelabel] {logs eventos};
\draw[arrow] (llvm) -- (mallory) node[midway, above, edgelabel] {binario\\instrumentado};
\draw[arrow] (cli) -- (abstractions) node[midway, above, edgelabel] {genera};

\end{tikzpicture}
\par}

\vspace{0.5cm}

A continuación se describen los componentes:

\subsubsection{CLI de Abstraktor}

El punto de entrada es una aplicación CLI escrita en Rust que coordina la ejecución de los demás componentes e implementa lógica de negocio para el análisis de código fuente, procesamiento de logs y generación de abstracciones. Sus responsabilidades incluyen:

\begin{itemize}
    \item \textbf{Coordinación de herramientas:} Invoca y configura el instrumentador LLVM mediante variables de entorno y ejecución de scripts, estableciendo el contexto necesario para la compilación instrumentada.
    
    \item \textbf{Extracción de anotaciones y generación de metadatos:} Procesa archivos de código fuente C/C++ mediante expresiones regulares para identificar anotaciones especiales insertadas como comentarios, y las serializa en formato JSON con información de rutas de archivos, números de línea, y especificaciones de variables y campos a capturar.
    
    \item \textbf{Procesamiento de logs y generación de abstracciones:} Parsea los logs de eventos, construye grafos de transiciones de estados por nodo del sistema distribuido, y exporta las representaciones gráficas en formato DOT (GraphViz), con opción de renderizado a PNG o PDF.
\end{itemize}

La aplicación Rust utiliza las siguientes bibliotecas principales:

\begin{itemize}
    \item \texttt{clap}: Framework para parseo de argumentos de línea de comandos con soporte para subcomandos
    \item \texttt{serde} y \texttt{serde\_json}: Serialización y deserialización de estructuras de datos
    \item \texttt{regex}: Análisis de patrones en código fuente para extracción de anotaciones
    \item \texttt{xshell}: Ejecución de comandos del sistema con manejo de directorios y variables de entorno
    \item \texttt{anyhow}: Manejo de errores con contexto enriquecido
\end{itemize}

\subsubsection{Instrumentador (LLVM)}

La instrumentación del código fuente se realiza mediante \textbf{afl-clang-fast}, un compilador basado en LLVM que inserta código en el paso de compilación. Se utilizó el instrumentador existente de AFL (American Fuzzy Lop) y se extendió para soportar la instrumentación selectiva basada en anotaciones. El instrumentador está escrito en C y se integra como un plugin de LLVM.

El proceso de instrumentación:

\begin{enumerate}
    \item El CLI de Rust configura las variables de entorno necesarias:
    \begin{itemize}
        \item \texttt{CC}: Ruta al wrapper \texttt{afl-clang-fast}
        \item \texttt{TARGETS\_FILE}: Ruta al archivo JSON con los targets de instrumentación
        \item \texttt{AFL\_CC}: Compilador base a utilizar (\texttt{clang-11})
    \end{itemize}
    
    \item Se invoca el script de compilación del sistema bajo prueba (\texttt{install.sh}), que utiliza automáticamente el compilador instrumentado a través de la variable \texttt{CC}
    
    \item El instrumentador de LLVM procesa el código durante la compilación, insertando llamadas que exponen el estado interno en los puntos especificados en el archivo de targets
    
    \item El resultado es un binario instrumentado que emite eventos durante su ejecución
\end{enumerate}

\subsubsection{Fuzzer (Mallory)}

\textbf{Mallory} es un framework de testing para sistemas distribuidos que combina fuzzing de red con simulación de fallas. Se utilizó el framework existente y se extendió el componente Mediator para soportar la recolección y persistencia de eventos de estado generados por los binarios instrumentados. Mallory está implementado principalmente en \textbf{Clojure} (usando Jepsen como base) con componentes en \textbf{Rust} (mediator y coverage server).

Arquitectura de Mallory:

\begin{itemize}
    \item \textbf{Infraestructura Docker:} Orquesta contenedores que ejecutan los nodos del sistema distribuido en un entorno de red controlado
    
    \item \textbf{Mediator (Rust):} Componente central que implementa algoritmos de aprendizaje por refuerzo (Q-learning) para guiar la exploración del espacio de estados.
    
    \item \textbf{Motor de fuzzing:} Genera tráfico de red, inyecta fallas y manipula condiciones de carrera
    
    \item \textbf{Recolección de eventos:} Captura las emisiones del binario instrumentado y las almacena en archivos de log con formato estructurado
\end{itemize}

\subsection{Interfaz de línea de comandos}

El CLI de Abstraktor está dividido en varios subcomandos que permiten ejecutar individualmente las diferentes etapas del flujo de trabajo para generar EPAs, otorgando flexibilidad al usuario para ejecutar pasos específicos según sea necesario:

\subsubsection{Comandos de instrumentación}

\begin{itemize}
    \item \texttt{get-targets}: Escanea directorios de código fuente C/C++ buscando anotaciones y genera un archivo JSON con los targets de instrumentación identificados.
    
    \item \texttt{llvm}: Configura variables de entorno e invoca el script de compilación del sistema bajo prueba utilizando el instrumentador LLVM con el archivo de targets especificado.
    
    \item \texttt{instrument}: Combina \texttt{get-targets} y \texttt{llvm} en un solo comando, automatizando todo el proceso de instrumentación.
\end{itemize}

\subsubsection{Comandos de configuración}

\begin{itemize}
    \item \texttt{setup docker}: Construye las imágenes Docker necesarias para el entorno de Mallory.
    
    \item \texttt{setup mediator}: Compila el componente Mediator de Mallory con opciones configurables (modo release, features de selfcheck y logsaving).
    
    \item \texttt{setup sut}: Configura el sistema bajo prueba.
    
    \item \texttt{setup all}: Ejecuta la configuración completa del entorno (Docker + Mediator).
\end{itemize}

\subsubsection{Comandos de ejecución y generación}

\begin{itemize}
    \item \texttt{run mallory}: Inicia el entorno de prueba de Mallory ejecutando los contenedores Docker configurados.
    
    \item \texttt{run mediator}: Ejecuta el binario del Mediator con parámetros de configuración (algoritmo Q-learning, tabla de eventos, factor de recompensa).
    
    \item \texttt{export-graphs}: Procesa los logs de eventos generados por Mallory, construye grafos de estados por nodo, y los exporta en formato DOT, PNG o PDF.
\end{itemize}

\subsection{Flujo de trabajo}

El flujo de trabajo típico para generar EPAs con Abstraktor involucra la interacción entre la CLI y los componentes de instrumentación y fuzzing:

\vspace{0.5cm}

{\centering
\begin{tikzpicture}[
  actor/.style={rectangle, draw, minimum width=2cm, minimum height=0.8cm, align=center, font=\small},
  lifeline/.style={draw, thick},
  call/.style={-{Latex[length=2.5mm]}, thick},
  return/.style={-{Latex[length=2.5mm]}, dashed, thick},
  note/.style={font=\tiny, align=left}
]

\node[actor] (dev) at (0,0) {Developer};
\node[actor] (cli) at (3.5,0) {Abstraktor};
\node[actor] (llvm) at (7,0) {LLVM};
\node[actor] (mallory) at (10.5,0) {Mallory};

\draw[lifeline] (dev) -- (0,-8);
\draw[lifeline] (cli) -- (3.5,-8);
\draw[lifeline] (llvm) -- (7,-8);
\draw[lifeline] (mallory) -- (10.5,-8);

\draw[call] (0,-1) -- (3.5,-1) node[midway, above, note] {instrument};
\draw[call] (3.5,-1.5) -- (7,-1.5) node[midway, above, note] {get-targets};
\draw[return] (7,-2) -- (3.5,-2) node[midway, above, note] {JSON targets};
\draw[call] (3.5,-2.5) -- (7,-2.5) node[midway, above, note] {instrumentar};
\draw[return] (7,-3) -- (3.5,-3) node[midway, above, note] {binario};
\draw[return] (3.5,-3.5) -- (0,-3.5) node[midway, above, note] {binario};

\draw[call] (0,-4) -- (3.5,-4) node[midway, above, note] {run mallory};
\draw[call] (3.5,-4.5) -- (10.5,-4.5) node[midway, above, note] {ejecutar};
\draw[return] (10.5,-5) -- (3.5,-5) node[midway, above, note] {logs eventos};
\draw[return] (3.5,-5.5) -- (0,-5.5) node[midway, above, note] {logs eventos};

\draw[call] (0,-6) -- (3.5,-6) node[midway, above, note] {export-graphs};
\draw[return] (3.5,-6.5) -- (0,-6.5) node[midway, above, note] {EPAs};

\end{tikzpicture}
\par}

\vspace{0.5cm}

El flujo completo consta de las siguientes etapas:

\begin{enumerate}
    \item \textbf{Anotación del código:} El desarrollador inserta anotaciones en el código fuente C/C++ para marcar los puntos de interés donde se desea capturar el estado interno.
    
    \item \textbf{Instrumentación:} El comando \texttt{instrument} extrae las anotaciones, genera el archivo JSON de targets, y compila el código usando el instrumentador LLVM para producir un binario instrumentado.
    
    \item \textbf{Fuzzing:} El comando \texttt{run mallory} ejecuta el binario instrumentado bajo el entorno de Mallory, que realiza fuzzing distribuido y recolecta los eventos de estado emitidos durante la ejecución.
    
    \item \textbf{Generación de EPAs:} El comando \texttt{export-graphs} procesa los logs de eventos, construye los grafos de transiciones de estados para cada nodo del sistema distribuido, y exporta las abstracciones en el formato deseado.
\end{enumerate}

\subsection{Sistema de anotaciones para instrumentación}

Abstraktor utiliza un sistema de anotaciones insertadas como comentarios en el código fuente C/C++ para especificar qué partes del estado interno deben ser instrumentadas. Se soportan tres tipos de anotaciones:

\subsubsection{ABSTRAKTOR\_BLOCK\_EVENT}

Instrumenta un bloque de código específico para capturar el estado de variables en ese punto de ejecución. Soporta navegación en estructuras anidadas mediante la sintaxis de índices de campos.

\textbf{Sintaxis:}
\begin{verbatim}
// ABSTRAKTOR_BLOCK_EVENT
// ABSTRAKTOR_BLOCK_EVENT: variable
// ABSTRAKTOR_BLOCK_EVENT: variable->campo
// ABSTRAKTOR_BLOCK_EVENT: variable->campo1->campo2
\end{verbatim}

\textbf{Ejemplo 1 - Sin especificar variable:}

\begin{verbatim}
// ABSTRAKTOR_BLOCK_EVENT
if (state == READY) {
    process_request();
}
\end{verbatim}

\textbf{Ejemplo 2 - Capturando una variable primitiva:}

\begin{verbatim}
// ABSTRAKTOR_BLOCK_EVENT: status
handle_message(status);
\end{verbatim}

\textbf{Ejemplo 3 - Accediendo a un campo de struct (posición 3):}

\begin{verbatim}
// ABSTRAKTOR_BLOCK_EVENT: request->3
process_field(request);
\end{verbatim}

\textbf{Ejemplo 4 - Accediendo a campos anidados (campo 2, luego campo 5):}

\begin{verbatim}
// ABSTRAKTOR_BLOCK_EVENT: config->2->5
apply_config(config);
\end{verbatim}

La navegación mediante índices numéricos (\texttt{->campo}) permite acceder a campos específicos de estructuras. Si \texttt{r} es un struct, \texttt{r->5} accede al campo en la posición 5. Si ese campo también es un struct, \texttt{r->5->6} accede al campo 6 del struct anidado. Los índices se utilizan en lugar de nombres de campos porque estos se pierden en la representación intermedia (IR) de LLVM durante la compilación.

\subsubsection{ABSTRAKTOR\_CONST}

Instrumenta un bloque de código para emitir un valor constante específico, útil para marcar estados o transiciones conocidas sin necesidad de examinar variables.

\textbf{Sintaxis:}
\begin{verbatim}
// ABSTRAKTOR_CONST: identificador
\end{verbatim}

\textbf{Ejemplo:}

\begin{verbatim}
// ABSTRAKTOR_CONST: LEADER_ELECTED
if (is_leader) {
    start_coordination();
}

// ABSTRAKTOR_CONST: FOLLOWER_MODE
wait_for_instructions();
\end{verbatim}

\subsubsection{ABSTRAKTOR\_FUNC}

Instrumenta una función completa, capturando el estado de los parámetros especificados. Solo puede trackear variables que sean parámetros de la función, no variables locales. Permite especificar múltiples parámetros separados por comas y soporta la misma sintaxis de navegación de campos que \texttt{ABSTRAKTOR\_BLOCK\_EVENT}.

\textbf{Sintaxis:}
\begin{verbatim}
// ABSTRAKTOR_FUNC: parametro1, parametro2
// ABSTRAKTOR_FUNC: parametro->campo
// ABSTRAKTOR_FUNC: param1->campo1, param2->campo2->campo3
\end{verbatim}

\textbf{Ejemplo 1 - Capturando un parámetro primitivo:}

\begin{verbatim}
// ABSTRAKTOR_FUNC: status
int process_message(int status) {
    perform_action(status);
    return status;
}
\end{verbatim}

\textbf{Ejemplo 2 - Capturando múltiples parámetros con acceso a campos:}

\begin{verbatim}
// ABSTRAKTOR_FUNC: node->1, status
void update_cluster_state(Node* node, int status) {
    apply_changes(node, status);
}
\end{verbatim}

\textbf{Ejemplo 3 - Navegación en campos anidados:}

\begin{verbatim}
// ABSTRAKTOR_FUNC: config->2->3, leader->5
int reconfigure_system(Config* config, Node* leader) {
    return apply_config(config, leader);
}
\end{verbatim}
