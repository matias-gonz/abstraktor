\section{Metodología aplicada}

El desarrollo de \textbf{Abstraktor} se llevó a cabo aplicando prácticas de ingeniería de software modernas, con un enfoque ágil basado en iteraciones cortas y mejora continua. Esta sección describe el contexto en el que se realizó el desarrollo, el proceso aplicado, las herramientas utilizadas y las prácticas de calidad implementadas.

\subsection{Contexto del desarrollo}

Este trabajo se realizó en colaboración con el \textbf{Laboratory on Foundations and Tools for Software Engineering (LaFHIS)} de la Facultad de Ciencias Exactas y Naturales de la Universidad de Buenos Aires. El laboratorio se encuentra investigando activamente la aplicación de \textbf{Enabledness-Preserving Abstractions (EPAs)} como técnica de verificación formal.

Uno de los objetivos del laboratorio es aplicar EPAs a algoritmos distribuidos. \textbf{Abstraktor} surge como respuesta a esta necesidad, proporcionando un framework automatizado para la instrumentación de código, ejecución guiada mediante fuzzing y generación de EPAs a partir de implementaciones reales de protocolos distribuidos.

El equipo de desarrollo estuvo compuesto por dos contribuidores principales: un estudiante de doctorado trabajando en su tesis y un estudiante de ingeniería de software completando su Trabajo Profesional Final. Ambos estudiantes trabajaron guiados por un director de investigación que, en términos del proceso de desarrollo, cumplió el rol de Product Owner. Adicionalmente, el director del Trabajo Profesional Final actuó como facilitador de reuniones y supervisor del desarrollo, asegurando la dirección y calidad del proyecto.

\subsection{Proceso de desarrollo}

El desarrollo de \textbf{Abstraktor} siguió un proceso ágil con iteraciones semanales, permitiendo una evolución incremental del sistema y ajustes dinámicos en función del progreso y los hallazgos experimentales.

\subsubsection{Gestión del backlog y priorización}

Se utilizó \textbf{GitHub Projects} para organizar el trabajo mediante un tablero Kanban, donde las tareas se priorizaron según su impacto en el proyecto y sus dependencias con otros componentes. Cada tarea fue estimada utilizando puntajes de dificultad (\textbf{1, 2 o 3}) en lugar de tiempos específicos, lo que permitió una planificación más flexible y adaptada a la naturaleza exploratoria del proyecto.

El desarrollo de los componentes se realizó en simultáneo, priorizando funcionalidades \textit{end-to-end} que permitieran validar el flujo completo del sistema desde etapas tempranas. Esta estrategia facilitó la identificación temprana de problemas de integración y permitió obtener retroalimentación sobre el funcionamiento del sistema de manera incremental.

\subsubsection{Flujo de trabajo con control de versiones}

Se utilizó \textbf{GitHub} para el control de versiones, aplicando un flujo de trabajo basado en \textit{feature branches} y \textit{pull requests}. Cada nueva funcionalidad o corrección se desarrolló en una rama separada, manteniendo los cambios pequeños. Los \textit{pull requests} incluyeron tests relevantes para cada cambio.

\subsection{Estrategia de testing y calidad}

El testing fue un componente central del proceso de desarrollo de \textbf{Abstraktor}, con un enfoque en garantizar la corrección de la lógica del sistema y la estabilidad de las integraciones con componentes externos.

\subsubsection{Testing automatizado}

Se implementaron dos niveles de testing:

\begin{itemize}
    \item \textbf{Tests unitarios}: Cubrieron extensivamente la lógica del modelo central, incluyendo el parseo de anotaciones, la construcción de targets de instrumentación y la generación de grafos de eventos.
    \item \textbf{Tests de integración}: Validaron las interacciones entre componentes del sistema, especialmente la integración con Mallory y la generación de abstracciones a partir de logs reales.
\end{itemize}

\subsubsection{Convenciones de código y linting}

Se aplicaron convenciones de código mediante el linter \textbf{Clippy} para Rust, asegurando consistencia en el estilo del código y detectando patrones problemáticos de manera automática.